/*
 * generated by Xtext 2.13.0
 */
package org.etri.slice.tools.adl.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1
import org.etri.slice.tools.adl.domainmodel.Context
import org.etri.slice.tools.adl.domainmodel.Control
import org.etri.slice.tools.adl.domainmodel.DomainDeclaration
import org.etri.slice.tools.adl.domainmodel.Event
import org.etri.slice.tools.adl.domainmodel.Exception
import org.etri.slice.tools.adl.domainmodel.Operation
import org.etri.slice.tools.adl.domainmodel.Property
import org.etri.slice.tools.adl.generator.GeneratorUtils
import org.etri.slice.tools.adl.scoping.DomainModelXImportSectionNamespaceScopeProvider

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class DomainmodelJvmModelInferrer extends AbstractModelInferrer {

	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension GeneratorUtils

	def dispatch infer(Context context, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {
		
		if(null === context.name)
			return;
			
		accept(context.toClass(context.fullyQualifiedName.adaptToSlice("context"))) [

			documentation = context.documentation

			if (context.superType !== null)
				superTypes += context.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.CONTEXT_BASE)

			// let's add a default constructor
			members += context.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += context.toConstructor [
				parameters += context.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]

			// now let's go over the features
			for (p : context.properties) {
				if(null !== p.name)
				{
					val field = p.toField(p.name, p.type)
					members += field
				}
			}

			// finally we want to have a nice toString methods.
			members += context.toToStringMethod(it)
		]
	}

	def dispatch infer(Exception exc, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {

		if (null === exc.name)
			return;

		accept(exc.toClass(exc.fullyQualifiedName.adaptToSlice(""))) [
			documentation = exc.documentation
			if (exc.superType !== null)
				superTypes += exc.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.EXCEPTION_INTERFACE)

			// let's add a default constructor
			members += exc.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += exc.toConstructor [
				parameters += exc.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]
		]
	}

	def dispatch infer(Event event, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {

		if (null === event.name)
			return;
			
		accept(event.toClass(event.fullyQualifiedName.adaptToSlice("event"))) [
			documentation = event.documentation
			if (event.superType !== null)
				superTypes += event.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.EVENT_BASE)

			// let's add a default constructor
			members += event.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += event.toConstructor [
				parameters += event.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]

			// now let's go over the features
			for (p : event.properties) {
				if(null !== p.name)
				{
					val field = p.toField(p.name, p.type)
					members += field
				}
			}

			// finally we want to have a nice toString methods.
			members += event.toToStringMethod(it)
		]
	}

	def dispatch infer(Control control, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {
		if(null === control.name)
			return;
			
		accept(control.toInterface(control.fullyQualifiedName.adaptToSlice("service").toString) [
			documentation = control.documentation

			if (control.superTypes.size() > 0) {
				for (superType : control.superTypes) {
					superTypes += superType.cloneWithProxies
				}
			}

			// now let's go over the features
			for (f : control.features) {
				switch f {
					// for properties we create a field, a getter and a setter
					Property: {
						if(null !== f.name)
						{
							val member = f.toField(f.name, f.type)
							member.static = true
							members += member
						}
					}
					// operations are mapped to methods
					Operation: {
						if(null !== f.name)
						{
							members += f.toMethod(f.name, f.type ?: inferredType) [
								documentation = f.documentation
								for (p : f.params) {
									parameters += p.toParameter(p.name, p.parameterType)
								}
	
								for (e : f.exceptions) {
									exceptions += e.cloneWithProxies;
								}
							]
						}
					}
				}
			}
		])
	}

	def dispatch infer(DomainDeclaration domain, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) 
	{	
		// implicit import
		DomainModelXImportSectionNamespaceScopeProvider.addImplicitImport(domain.fullyQualifiedName.adaptToSlice(""))
		
		super.infer(domain, acceptor, prelinkingPhase)
	}
}
