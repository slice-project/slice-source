/*
 * generated by Xtext 2.13.0
 */
package org.etri.slice.tools.adl.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1
import org.etri.slice.tools.adl.domainmodel.AgentDeclaration
import org.etri.slice.tools.adl.domainmodel.Call
import org.etri.slice.tools.adl.domainmodel.Context
import org.etri.slice.tools.adl.domainmodel.Control
import org.etri.slice.tools.adl.domainmodel.Event
import org.etri.slice.tools.adl.domainmodel.Exception
import org.etri.slice.tools.adl.domainmodel.Operation
import org.etri.slice.tools.adl.domainmodel.Property
import org.etri.slice.tools.adl.domainmodel.Publish
import org.etri.slice.tools.adl.generator.ADLGenerator
import org.etri.slice.tools.adl.generator.GeneratorUtils

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class DomainmodelJvmModelInferrer extends AbstractModelInferrer {

	@Inject extension JvmTypesBuilder
	@Inject extension IQualifiedNameProvider
	@Inject extension GeneratorUtils

	def dispatch infer(Context context, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {
		
		if(null === context.name)
			return;
			
		accept(context.toClass(context.fullyQualifiedName.adaptToSlice("context"))) [

			documentation = context.documentation

			if (context.superType !== null)
				superTypes += context.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.CONTEXT_BASE)

			// let's add a default constructor
			members += context.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += context.toConstructor [
				parameters += context.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]

			// now let's go over the features
			for (p : context.properties) {
				if(null !== p.name)
				{
					val field = p.toField(p.name, p.type)
					members += field
				}
			}

			// finally we want to have a nice toString methods.
			members += context.toToStringMethod(it)
		]
	}

	def dispatch infer(Exception exc, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {

		if (null === exc.name)
			return;

		accept(exc.toClass(exc.fullyQualifiedName.adaptToSlice(""))) [
			documentation = exc.documentation
			if (exc.superType !== null)
				superTypes += exc.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.EXCEPTION_INTERFACE)

			// let's add a default constructor
			members += exc.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += exc.toConstructor [
				parameters += exc.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]
		]
	}

	def dispatch infer(Event event, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {

		if (null === event.name)
			return;
			
		accept(event.toClass(event.fullyQualifiedName.adaptToSlice("event"))) [
			documentation = event.documentation
			if (event.superType !== null)
				superTypes += event.superType.cloneWithProxies
			else
				superTypes += typeRef(CommonInterfaces.EVENT_BASE)

			// let's add a default constructor
			members += event.toConstructor[]

			// and one which can be called with a lambda for initialization.
			val procedureType = typeRef(Procedure1, typeRef(it)) /* Procedure<MyEntity> */
			members += event.toConstructor [
				parameters += event.toParameter("initializer", procedureType)
				// here we implement the body using black box Java code.
				body = '''
					initializer.apply(this);
				'''
			]

			// now let's go over the features
			for (p : event.properties) {
				if(null !== p.name)
				{
					val field = p.toField(p.name, p.type)
					members += field
				}
			}

			// finally we want to have a nice toString methods.
			members += event.toToStringMethod(it)
		]
	}

	def dispatch infer(Control control, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {
		if(null === control.name)
			return;
			
		accept(control.toInterface(control.fullyQualifiedName.adaptToSlice("service").toString) [
			documentation = control.documentation

			if (control.superTypes.size() > 0) {
				for (superType : control.superTypes) {
					superTypes += superType.cloneWithProxies
				}
			}

			// now let's go over the features
			for (f : control.features) {
				switch f {
					// for properties we create a field, a getter and a setter
					Property: {
						if(null !== f.name)
						{
							val member = f.toField(f.name, f.type)
							member.static = true
							members += member
						}
					}
					// operations are mapped to methods
					Operation: {
						if(null !== f.name)
						{
							members += f.toMethod(f.name, f.type ?: inferredType) [
								documentation = f.documentation
								for (p : f.params) {
									parameters += p.toParameter(p.name, p.parameterType)
								}
	
								for (e : f.exceptions) {
									exceptions += e.cloneWithProxies;
								}
							]
						}
					}
				}
			}
		])
	}

	def dispatch infer(AgentDeclaration agent, extension IJvmDeclaredTypeAcceptor acceptor, boolean prelinkingPhase) {

//		accept(agent.toClass(agent.fullyQualifiedName.adaptToSlice("Agent$$$"))) [
//			documentation = agent.documentation
//
//			if (!prelinkingPhase) {
//				// Behavior
//				for (behavior : agent.behaviorSet.behaviors) {
//					val situation = behavior.situation
//
//					for (type : situation.types) {
//						val field = type.toField(type.simpleName.toLowerCase, type)
//						members += field
//
////					System.out.println(">>> situation field " + field);
////					System.out.println(">>> situation type " + type);
//					}
//
//					val action = behavior.action
//					switch action {
//						Publish: {
//							val field = action.toField(action.event.simpleName.toLowerCase, action.event)
//							members += field
//						}
//						Call: {
////						System.out.println(">>> Call " + action.control.simpleName);
//							val field = action.toField(action.control.simpleName.toLowerCase, action.control.typeRef())
//							members += field
//
////						System.out.println(">>> Call typeRef " + action.control.typeRef());
////						System.out.println(">>> Call field " + field);
//						}
//					}
//				}
//
//				// Commands
//				for (commandSet : agent.commandSets) {
//
//					var field = commandSet.control.toField(commandSet.control.simpleName.toLowerCase,
//						commandSet.control)
//
//					if (!members.contains(field))
//						members += field
//
//					for (command : commandSet.commands) {
//						for (commandContext : command.contexts) {
//							field = commandSet.control.toField(commandContext.context.simpleName,
//								commandContext.context.typeRef())
//
//							if (!members.contains(field))
//								members += field
//						}
//
//						field = commandSet.control.toField(command.action.simpleName, command.action.typeRef)
//
//						if (!members.contains(field))
//							members += field
//					}
//				}
//			}
//		]
	}
}
